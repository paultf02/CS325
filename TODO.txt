check operator precedence
why are there two minus signs in grammar? line 29 and line 31 in transformedgrammar3
why are there no commas in params?
do we add EOF to the grammar?

now we have first and follow sets
we need to build the table and see how many cells have multiple entries
can we change the grammar so it becomes LL(1)?
can we easily modify the code so we can parse LL(k)?

for ll(k) > 2 we need to compute first_k and follow_k sets
how do we do this

epsilon cannot be in any follow sets

revise the whole no epsilon productions stuff
in the grammar how can you just take void as a param?
int main(void){}; 
is the above valid?
see https://stackoverflow.com/questions/693788/is-it-better-to-use-c-void-arguments-void-foovoid-or-not-void-foo

for rval1 in the ll parsing table, can we just pick the production that is not epsilon if the next character is + or whatever?

let the terminal in the second index of tuple be called +1 token.
('decl', '"int"') : [(7, 0), (7, 1)] # if +2 is IDENT and +3 is ; then do (7,0) | if +2 is IDENT and +3 is ( then do (7, 1)
('decl', '"float"') : [(7, 0), (7, 1)] # if +2 is IDENT and +3 is ; then do (7,0) | if +2 is IDENT and +3 is ( then do (7, 1)
('decl', '"bool"') : [(7, 0), (7, 1)] # if +2 is IDENT and +3 is ; then do (7,0) | if +2 is IDENT and +3 is ( then do (7, 1)
('return_stmt', '"return"') : [(25, 0), (25, 1)] # if +2 is IDENT then do (25, 0) | otherwise do (25, 1)
('expr', 'IDENT') : [(26, 0), (26, 1)] # if +2 is = then do (26, 0) | otherwise do (26, 1)
('rval1', '"+"') : [(29, 8), (29, 13)] # never do (29, 13) ## CHECK THIS
('rval1', '"-"') : [(29, 9), (29, 13)]
('rval1', '"*"') : [(29, 10), (29, 13)]
('rval1', '"/"') : [(29, 11), (29, 13)]
('rval1', '"%"') : [(29, 12), (29, 13)]
('rval1', '"<"') : [(29, 5), (29, 13)]
('rval1', '">"') : [(29, 7), (29, 13)]
('rval1', '"<="') : [(29, 4), (29, 13)]
('rval1', '">="') : [(29, 6), (29, 13)]
('rval1', '"=="') : [(29, 2), (29, 13)]
('rval1', '"!="') : [(29, 3), (29, 13)]
('rval1', '"||"') : [(29, 0), (29, 13)]
('rval1', '"&&"') : [(29, 1), (29, 13)]

After we have a parse tree what semantic analysis needs to be done?
declaration and type
type checking
variable scope
type inference / coercion
where can x be stored: register, local, global, heap, static
Array-bound checking # miniC does not have arrays
Type mismatch
Undeclared variable
Reserved identifier misuse.
Multiple declaration of variable in a scope.
Accessing an out of scope variable.
Actual and formal parameter mismatch.

grammar enforced precedence

To do:
Add grammar enforced operator precedence
Remove left recursion
Compute first and follow sets
Use appropriate lookahead for certain cases to determine production to use
Make a predictive recursive descent parser. No backtracking.
Create parse tree
Turn parse tree into abstract syntax tree
Pretty print abstract syntax tree (see clang AST output and model it on that)
Turn abstract syntax tree into LLVM IR by running recursive codegen() method
    This will require type checking and variable scope (any other semantic checks?)
Add meaningful error messages to lexer, parser, semantic checker and codegen

1126 cells with 0 entries
156 cells with 1 entry
48 cells with more than 1 entry
cells with more than 1 entry:
('decl', "'int'") : [(7, 0), (7, 1)]
('decl', "'float'") : [(7, 0), (7, 1)]
('decl', "'bool'") : [(7, 0), (7, 1)]
('return_stmt', "'return'") : [(25, 0), (25, 1)]
('expr', 'IDENT') : [(26, 0), (26, 1)]
('rval', "'('") : [(27, 0), (27, 1)]
('rval', "'-'") : [(27, 0), (27, 1)]
('rval', "'!'") : [(27, 0), (27, 1)]
('rval', 'BOOL_LIT') : [(27, 0), (27, 1)]
('rval', 'INT_LIT') : [(27, 0), (27, 1)]
('rval', 'FLOAT_LIT') : [(27, 0), (27, 1)]
('rval', 'IDENT') : [(27, 0), (27, 1)]
('rval1', "'('") : [(28, 0), (28, 1)]
('rval1', "'-'") : [(28, 0), (28, 1)]
('rval1', "'!'") : [(28, 0), (28, 1)]
('rval1', 'BOOL_LIT') : [(28, 0), (28, 1)]
('rval1', 'INT_LIT') : [(28, 0), (28, 1)]
('rval1', 'FLOAT_LIT') : [(28, 0), (28, 1)]
('rval1', 'IDENT') : [(28, 0), (28, 1)]
('rval2', "'('") : [(29, 0), (29, 1), (29, 2)]
('rval2', "'-'") : [(29, 0), (29, 1), (29, 2)]
('rval2', "'!'") : [(29, 0), (29, 1), (29, 2)]
('rval2', 'BOOL_LIT') : [(29, 0), (29, 1), (29, 2)]
('rval2', 'INT_LIT') : [(29, 0), (29, 1), (29, 2)]
('rval2', 'FLOAT_LIT') : [(29, 0), (29, 1), (29, 2)]
('rval2', 'IDENT') : [(29, 0), (29, 1), (29, 2)]
('rval3', "'('") : [(30, 0), (30, 1), (30, 2), (30, 3), (30, 4)]
('rval3', "'-'") : [(30, 0), (30, 1), (30, 2), (30, 3), (30, 4)]
('rval3', "'!'") : [(30, 0), (30, 1), (30, 2), (30, 3), (30, 4)]
('rval3', 'BOOL_LIT') : [(30, 0), (30, 1), (30, 2), (30, 3), (30, 4)]
('rval3', 'INT_LIT') : [(30, 0), (30, 1), (30, 2), (30, 3), (30, 4)]
('rval3', 'FLOAT_LIT') : [(30, 0), (30, 1), (30, 2), (30, 3), (30, 4)]
('rval3', 'IDENT') : [(30, 0), (30, 1), (30, 2), (30, 3), (30, 4)]
('rval4', "'('") : [(31, 0), (31, 1), (31, 2)]
('rval4', "'-'") : [(31, 0), (31, 1), (31, 2)]
('rval4', "'!'") : [(31, 0), (31, 1), (31, 2)]
('rval4', 'BOOL_LIT') : [(31, 0), (31, 1), (31, 2)]
('rval4', 'INT_LIT') : [(31, 0), (31, 1), (31, 2)]
('rval4', 'FLOAT_LIT') : [(31, 0), (31, 1), (31, 2)]
('rval4', 'IDENT') : [(31, 0), (31, 1), (31, 2)]
('rval5', "'('") : [(32, 0), (32, 1), (32, 2), (32, 3)]
('rval5', "'-'") : [(32, 0), (32, 1), (32, 2), (32, 3)]
('rval5', "'!'") : [(32, 0), (32, 1), (32, 2), (32, 3)]
('rval5', 'BOOL_LIT') : [(32, 0), (32, 1), (32, 2), (32, 3)]
('rval5', 'INT_LIT') : [(32, 0), (32, 1), (32, 2), (32, 3)]
('rval5', 'FLOAT_LIT') : [(32, 0), (32, 1), (32, 2), (32, 3)]
('rval5', 'IDENT') : [(32, 0), (32, 1), (32, 2), (32, 3)]
('rval7', 'IDENT') : [(34, 1), (34, 2)]